#![feature(allocator_api)]
#![no_std]
#![no_main]

use devicetree::parsed::Devicetree;
use spin::Once;

use self::{cpu::Cpuid, memory::layout::MemoryLayout};

extern crate alloc;

#[macro_use]
mod console;
#[macro_use]
mod log;

mod boot;
mod cpu;
mod interrupt;
mod memory;
mod sync;
mod task;

const ONIX_VERSION: &str = env!("CARGO_PKG_VERSION");
// Generated by https://www.asciiart.eu/text-to-ascii-art
// with Font = Big
const ONIX_LOGO: &str = r"
  ____        _
 / __ \      (_)
| |  | |_ __  ___  __
| |  | | '_ \| \ \/ /
| |__| | | | | |>  <
 \____/|_| |_|_/_/\_\
";

static PRIMARY_CPUID: Once<Cpuid> = Once::new();
static DEVICETREE: Once<Devicetree> = Once::new();

fn primary_cpu_entry(cpuid: Cpuid, dtb_pa: usize) -> *mut u8 {
    PRIMARY_CPUID.call_once(|| cpuid);

    println!();
    println!();
    println!("Onix v{ONIX_VERSION}");
    println!("{ONIX_LOGO}");

    let memory_layout = init_memory(dtb_pa);
    let dtree = DEVICETREE.get().unwrap();
    cpu::init(dtree).unwrap();
    cpu::set_current_cpuid(cpuid);
    interrupt::init(cpuid);
    memory::kernel_space::init(&memory_layout).unwrap();
    memory::kernel_space::apply();

    let stack = memory::kernel_space::allocate_kernel_stack().unwrap();
    let stack_top = stack.top();
    core::mem::forget(stack);
    stack_top as *mut u8
}

fn secondary_cpu_entry(cpuid: Cpuid) -> *mut u8 {
    cpu::set_current_cpuid(cpuid);
    memory::kernel_space::apply();

    let stack = memory::kernel_space::allocate_kernel_stack().unwrap();
    let stack_top = stack.top();
    core::mem::forget(stack);
    stack_top as *mut u8
}

fn main() -> ! {
    let primary_cpuid = PRIMARY_CPUID.get().unwrap();
    let is_primary = *primary_cpuid == cpu::current().id();

    if is_primary {
        unsafe {
            start_secondary_cpus();
        }
        task::scheduler::init();
    }

    interrupt::trap::apply();
    interrupt::timer::start();

    info!("CPU initialized");

    let tid = task::spawn(task_entry).unwrap();
    info!("Task {tid} spawned");
    let tid = task::spawn(task_entry).unwrap();
    info!("Task {tid} spawned");

    task::scheduler::start();
}

extern "C" fn task_entry() -> ! {
    let int = interrupt::push_disabled();
    let task = task::scheduler::current_task().unwrap();
    drop(int);

    loop {
        info!("hello from task {}", task.id());
        interrupt::wait();
    }
}

fn init_memory(dtb_pa: usize) -> MemoryLayout {
    let dtb = unsafe { devicetree::flattened::Devicetree::from_addr(dtb_pa) }.unwrap();
    let memory_layout = MemoryLayout::new(&dtb).unwrap();

    // initialize heap
    unsafe {
        memory::allocator::add_heap_ranges(memory_layout.initial_heap_ranges());
    }

    // parse devicetree blob
    DEVICETREE.call_once(|| dtb.parse().unwrap());

    // reuse devicetree blob range as heap
    unsafe {
        memory::allocator::add_heap_ranges([memory_layout.dtb_range()]);
    }

    memory_layout
}

unsafe fn start_secondary_cpus() {
    for cpu in cpu::get_all() {
        if cpu.is_current() {
            continue;
        }
        unsafe {
            boot::start_secondary_cpu(cpu.id());
        }
    }

    // reuse boot stack as heap
    unsafe {
        memory::allocator::add_heap_ranges([memory::layout::kernel_boot_stack_range()]);
    }
}
